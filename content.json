{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"zhanghy7","url":"http://zhanghy7.github.io"},"pages":[],"posts":[{"title":"js之事件","slug":"js之事件","date":"2019-01-14T10:32:58.000Z","updated":"2019-01-14T10:35:25.579Z","comments":true,"path":"2019/01/14/js之事件/","link":"","permalink":"http://zhanghy7.github.io/2019/01/14/js之事件/","excerpt":"","text":"js之事件容易忽略的点input和change事件区别input事件在用户输入时候就触发，但是通过js改变值、或者选择值时候不能触发； onchange事件只有在元素失去焦点时候触发。","categories":[],"tags":[]},{"title":"css常见问题","slug":"css","date":"2019-01-14T10:30:04.000Z","updated":"2019-01-14T10:30:54.753Z","comments":true,"path":"2019/01/14/css/","link":"","permalink":"http://zhanghy7.github.io/2019/01/14/css/","excerpt":"","text":"css常见问题inline-block元素间距留白问题","categories":[],"tags":[]},{"title":"","slug":"2019目标","date":"2019-01-13T06:05:48.297Z","updated":"2019-01-14T06:46:46.641Z","comments":true,"path":"2019/01/13/2019目标/","link":"","permalink":"http://zhanghy7.github.io/2019/01/13/2019目标/","excerpt":"","text":"19年目标： 搞点东西出来： 痛点：hexo admin插件另起标题时一打字连带的打出了上一个标题中的所有正文。。。 痛点：使用北京公交集团查询公交的时候信息不准确，导致上班迟到。具体情况是从家往出走看着再有三站就到我这了，结果等了10分钟后再看显示还有10站。。心里一万匹草泥马。。。有这时间我都快走到地铁站了。。。 思考：自己写一个查询实时公交的东西 技术上： 性能优化方面，着重学习谷歌开发者网站。 自己负责的项目保质保量完成，delay次数少于2次，bug量能够减少到3个每天。 项目代码都有注释、对所做项目有使用和开发已经项目阶段性完成的的文档整理、总结， vue、react框架的熟练掌握，为项目输出高质量的通用组件2个以上。 发现开发中的痛点(至少两个)，并给出解决方案。 两篇高质量文章输出，三次高质量的分享。 再看一遍红宝书、并深入学习es6，让自己的js水平达到高级水平。 underscore源码的重点部分阅读学习完。 react源码阅读和学习完成。 熟练掌握css的常见布局实现方式，并深入了解原理。 http协议的学习。 掌握常见的数据结构和算法，能理解思想、学会思考。 年底技术水平能到到p6。 业务上： 积极推动项目进度，明确知道各个角色的时间点和进度。 项目评审中至少能提出2个以上问题。 软素质上： 阅读2本非技术方面的书（我以前基本从来不看非技术的书，包括小说，所以我感觉2本对我来说不少了hh）。 和别人沟通中用“多多思考”来替换以前的“不知道”。。 2~3年计划： 技术上在前端成长到高级水平，并熟悉服务器端，熟悉整套网站开发、上线和运维的整体流程。 业务上能够成长为一个非常熟悉公司内部业务，并能够通过自己的努力去协调各个方面推动业务的顺利落地。","categories":[],"tags":[]},{"title":"webpack打包优化","slug":"vue项目webpack打包优化","date":"2019-01-08T04:09:45.000Z","updated":"2019-01-14T03:21:09.077Z","comments":true,"path":"2019/01/08/vue项目webpack打包优化/","link":"","permalink":"http://zhanghy7.github.io/2019/01/08/vue项目webpack打包优化/","excerpt":"","text":"webpack打包优化优化前： https://juejin.im/post/5c1fa158f265da613c09cb36?utm_medium=fe&amp;utm_source=weixinqun cacheDirectory:https://webpack.docschina.org/loaders/babel-loader/","categories":[],"tags":[]},{"title":"vue","slug":"vue之自定义事件和参数$event","date":"2019-01-04T13:19:35.000Z","updated":"2019-01-14T10:18:55.900Z","comments":true,"path":"2019/01/04/vue之自定义事件和参数$event/","link":"","permalink":"http://zhanghy7.github.io/2019/01/04/vue之自定义事件和参数$event/","excerpt":"","text":"vuevue字符串模板和HTML模板HTML模板123456// 定义Vue.component(&apos;child&apos;, &#123;// 在 JavaScript 中使用 camelCaseprops: [&apos;myMessage&apos;],template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;&#125;) 123// 使用&lt;!-- 在 HTML 中使用kebab-case --&gt;&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt; html模板概念通过template:定义的组件。 写法：要求不能使用驼峰命名，必须使用中划线命名； 原因：HTML不区分大小写，使用HTML模板的组件会在浏览器初始加载的时候就被渲染，所以需要遵守HTML规则，否则将渲染失败，而Vue需要等到初次渲染完毕后才能拿到DOM，进行DOM的模板插入。 vue中data为函数的原因因为正常情况下data需要的是一个对象，但是对象是引用类型的，如果有超过一个组件实例，那么改变一个的数据就会引发连锁效应，所以这里vue很聪明的把data定义为一个函数，利用这个函数返回新的对象，每个对象就是独立的。 vue、react方法写法由于es6的箭头函数在定义的时候就已经决定了this指向，在组件内定义方法的时候this是指向window的，所以需要使用es5进行方法定义，这样就可以在使用的时候动态指向this。react中的话可以可以在constructor中绑定this。 vue中组件中所有方法中的this都被绑定到他自身的实例了。。 vue中两种组件注册方式全局注册为什么vue中注册全局组件要放在实例化之前简单来理解：vue你可以理解为一个对象模板，使用vue就需要new进行实例化，当你已经实例化了，再去改变模板有何意义？自然出不来 深层原理：vue本质上就是使用Vue构造函数实例化一个对象，对象内部会去处理所有的模板以及数据，在实例化完毕之后再去改变构造函数，还想让之前实例化的对象中拥有新添加的东西那肯定是不行的。12345678910ex: function Person(name) &#123; this.name=name &#125; Person.prototype.isMan=&apos;no&apos; person = new Person(&apos;Jack&apos;) // Person &#123;name: &quot;Jack&quot;&#125; // 实例化之后再去修改原型就对之前的person实例无效了。。 Person.prototype.getName = function () &#123;console.log(this.name)&#125; vue中is就是有些元素内部不能使用自定义标签或者自定义标签内也不能放某些特殊的标签，这时候就要用is代替一下，让html语法符合规则验证。is属于指定要在内部使用的标签。 vue中v-model原理，input事件vue自定义事件铺垫—组件通信父子组件自定义事件：父组件通过v-on绑定事件a，子组件中通过this.$emit(name[,args])触发。 非父子组件通过定义一个中央事件总线eventBus，在组件A中通过eventBus.$on(name,callback)绑定，在组件B中通过eventBus.$emit(name[,args])触发 123456789var bus = new Vue()// 触发组件 A 中的事件bus.$emit('id-selected', 1)// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;) 一、不传参直接通过this.$emit或者eventBus.$emit触发 二、传参监听自定义事件的时候已经传入参数12// 父组件 监听自定义事件的时候已经传入了id这个字段&lt;rowView @showInfo=\"showInfo(item.id)\"&gt;&lt;/rowView&gt; 1234// 子组件show_info(arg) &#123;// 向详情页传入当前状态 this.$emit(\"showInfo\",this.rowData.status_text); &#125;, 这里父组件要能接收到子组件传入的其他参数有这么几种办法： 第一种方式只适合触发事件时候传入一个参数的情况：@showInfo=&quot;showInfo(item.id,$event)&quot;&gt;，父组件中添加$event参数，这样父组件事件触发时候第二个参数就能接收到子组件触发传来的数据。 $event 在dom原生事件中传入$event时候会被赋值为原生事件对象。 在自定义事件中传入$event时候会被赋予触发时传入的第一个参数值 通过arguments来获取其他数据，在父组件中@showInfo=&quot;showInfo(item.id,arguments)&quot;&gt; 不在监听的时候传入数据，统一数据传入都写在方法中 1234567//父组件&lt;rowView @showInfo=\"showInfo\"&gt;&lt;/rowView&gt;showInfo(arg) &#123; // 将id的处理写在方法内部 this.id = this.item.id this.aaa = arg&#125; 1234// 子组件show_info(arg) &#123;// 向详情页传入当前状态 this.$emit(\"showInfo\",this.rowData.status_text); &#125;, Todo:根据arguments看一下vue的监听触发源码","categories":[],"tags":[]},{"title":"html知识点","slug":"html知识点","date":"2019-01-04T11:50:13.000Z","updated":"2019-01-08T13:33:16.318Z","comments":true,"path":"2019/01/04/html知识点/","link":"","permalink":"http://zhanghy7.github.io/2019/01/04/html知识点/","excerpt":"","text":"html知识点伪类、伪元素input、img、iframe不支持伪元素，因为伪类是要插入到容器内部一起渲染的，而这几个标签是不能包含其他元素的。 行内元素margin和padding无效问题margin和padding对行内元素都是左右有效、上下无效，如果需要设置上下，需要把它改为非行内元素，例如inline-block 浮动浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。首先元素浮动后，产生的特性1、块元素在一排显示2、内联元素支持宽高3、不设置宽度，内容撑开宽度4、脱离文档流5、提升层级半层 凡是float属性值不为none,元素display都被当做block(除去flex),但不是真正的块级元素,而是拥有了block元素的特性。clear:both本质上是让自己不和浮动元素同在一行 float属性详解 bfc块格式化上下文（BFC）有下面几个特点： BFC是就像一道屏障，隔离出了BFC内部和外部，内部和外部区域的渲染相互之间不影响。BFC有自己的一套内部子元素渲染的规则，不影响外部渲染，也不受外部渲染影响。 BFC的区域不会和外部浮动盒子的外边距区域发生叠加。也就是说，外部任何浮动元素区域和BFC区域是泾渭分明的，不可能重叠。 BFC在计算高度的时候，内部浮动元素的高度也要计算在内。也就是说，即使BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，高度是大于等于浮动元素的高度的。 HTML结构中，当构建BFC区域的元素紧接着一个浮动盒子时，即，是该浮动盒子的兄弟节点，BFC区域会首先尝试在浮动盒子的旁边渲染，但若宽度不够，就在浮动元素的下方渲染。[看这里] bfc","categories":[],"tags":[]},{"title":"移动端适配方案","slug":"移动端适配方案","date":"2018-12-25T12:40:11.000Z","updated":"2019-01-08T04:14:04.693Z","comments":true,"path":"2018/12/25/移动端适配方案/","link":"","permalink":"http://zhanghy7.github.io/2018/12/25/移动端适配方案/","excerpt":"","text":"移动端适配方案http://www.vsoui.com/2017/03/15/mobile-FE-Adaptive/ 移动端bughttps://github.com/markyun/My-blog/issues/88 长按元素click事件不触发的原因：移动端click事件一般要延迟300ms，因为浏览器会在这个事件段内去判断是否是double click，在300ms内手指离开屏幕click触发，但是长按超过300ms后浏览器没检测到第二次点击不能触发double click事件，并且这时候click也不会被触发了。 移动端1px问题","categories":[],"tags":[]},{"title":"","slug":"css基础之文字宽高","date":"2018-12-25T09:07:28.388Z","updated":"2018-12-25T09:07:30.876Z","comments":true,"path":"2018/12/25/css基础之文字宽高/","link":"","permalink":"http://zhanghy7.github.io/2018/12/25/css基础之文字宽高/","excerpt":"","text":"css基础之文字宽高","categories":[],"tags":[]},{"title":"css--页面布局","slug":"css-页面布局","date":"2018-12-24T03:04:48.000Z","updated":"2018-12-24T03:04:51.377Z","comments":true,"path":"2018/12/24/css-页面布局/","link":"","permalink":"http://zhanghy7.github.io/2018/12/24/css-页面布局/","excerpt":"","text":"页面布局","categories":[],"tags":[]},{"title":"react项目实现的ssr","slug":"react项目实现的ssr","date":"2018-12-22T13:30:00.000Z","updated":"2018-12-24T04:27:37.041Z","comments":true,"path":"2018/12/22/react项目实现的ssr/","link":"","permalink":"http://zhanghy7.github.io/2018/12/22/react项目实现的ssr/","excerpt":"","text":"react项目实现的ssr名词解释 同构：开发一套多个平台都可以跑的代码，例如同时可以在client和node端跑。https://juejin.im/entry/5b1631085188257d492adc9e ssr(server-side rendering)：服务端渲染 关键APIreact提供了四个方法将虚拟dom转为html文本： 服务器端客户端皆可用： ReactDOMServer.renderToString(element) ReactDOMServer.renderToStaticMarkup(element) 服务器端可用： ReactDOMServer.renderToNodeStream(element) ReactDOMServer.renderToStaticNodeStream(element) hydrate： react16提供的新的API专门为服务端渲染做首屏优化。 一个节点上有服务器渲染标记，那么react会保留此dom结构，只是往dom上去绑定事件处理程序，从而达到一个最佳的首屏渲染表现，在客户端用hydrate代替render方法。 让服务端支持JSX引入babel-register. 服务端和客户端的执行区别生命周期不同服务端只能走到componentWillMount(),todo:componentWillMount周期内能干什么？ node环境中没有浏览器特有的全局对象和方法这里就可以用到componentWillMount周期了，在这个周期就可以访问到浏览器特有的属性和方法了。 项目开发：命令行工具生成API 参考文献 https://juejin.im/entry/5abb51985188255569190a63","categories":[{"name":"react","slug":"react","permalink":"http://zhanghy7.github.io/categories/react/"},{"name":"ssr","slug":"react/ssr","permalink":"http://zhanghy7.github.io/categories/react/ssr/"}],"tags":[]},{"title":"SEO","slug":"你经常提到的SEO你知道懂吗？","date":"2018-12-21T07:10:21.569Z","updated":"2018-12-23T14:51:56.574Z","comments":true,"path":"2018/12/21/你经常提到的SEO你知道懂吗？/","link":"","permalink":"http://zhanghy7.github.io/2018/12/21/你经常提到的SEO你知道懂吗？/","excerpt":"","text":"SEO","categories":[],"tags":[]},{"title":"js之原型链","slug":"js之原型链","date":"2018-12-19T12:30:00.000Z","updated":"2019-01-14T16:03:39.410Z","comments":true,"path":"2018/12/19/js之原型链/","link":"","permalink":"http://zhanghy7.github.io/2018/12/19/js之原型链/","excerpt":"","text":"js之原型链js中万物皆对象吗 由一个简单的对象实例说起： 12345678910111213141516171819function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype.getName = function () &#123; console.log(this.name)&#125;const person = new Person('Tom', 12)person.getName() // Tomconsole.log(person.__proto__) // &#123;getName: ƒ, constructor: ƒ&#125;console.log(person.constructor) /** * ƒ Person (name, age) &#123; this.name = name this.age = age &#125; */ 先不解释代码，介绍几个js中非常重要的概念： prototype prototype:函数的一个属性，叫原型对象。js中函数所特有的属性，如果是这个函数是构造函数，那么它的实例对象上也能访问到prototype上的属性，其实就是一种变相的“继承”。 《JavaScript权威指南》 Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype. 每一个js对象都有另一个与之相关联的对象，另一个对象就是原型对象，此对象继承原型对象上的属性和方法。 翻译出来就是每个JS对象一定对应一个原型对象，并从原型对象继承属性和方法。 __proto__ __proto__：可称为隐式原型，所有js对象(除去null)都有的一个属性，一个对象的隐式原型指向构造该对象的构造函数的原型。 由于__proto__是个内部属性，不建议外部直接使用，现在一般建议使用Object.getPrototypeof方法来查看原型对象。 constructor：所有原型对象都有的一个属性，指向当前对象的(自己的)构造函数。 原型链文字总结 js中所有对象都是由构造函数生成的，而js中函数拥有属性prototype，由它实例化得到的是js对象，js对象(除去null)又都拥有__proto__属性，并且这个属性是指向构造函数的prototype，从而实例对象可以访问到构造函数原型对象上的属性或方法。 这也就是js的原型链。 原型链结合开始代码的图示总结 由于Function的原型也是对象那么它的构造函数是Object,所以Function原型的隐式原型(__proto)指向的是Object的原型(prototype)；Function自己也是对象，而它的构造函数就是他自己，所以他的隐式原型(__proto)指向他自己的原型。 而Object.prototype是没有原型的，隐式原型(__proto)指向null,Object又是Function的实例，所以他的隐式原型(__proto)指向Function的原型。 这就是js中著名的先有鸡还是先有蛋的问题。 参考文献 http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto https://github.com/creeperyang/blog/issues/9","categories":[{"name":"js","slug":"js","permalink":"http://zhanghy7.github.io/categories/js/"}],"tags":[]},{"title":"css基础之nth-child和nth-of-type","slug":"css基础之nth-child和nth-of-type","date":"2018-12-18T12:57:00.000Z","updated":"2018-12-23T14:49:26.116Z","comments":true,"path":"2018/12/18/css基础之nth-child和nth-of-type/","link":"","permalink":"http://zhanghy7.github.io/2018/12/18/css基础之nth-child和nth-of-type/","excerpt":"","text":"css基础之nth-child和nth-of-type 参考文献 匹配除第一个元素外的子元素 segment总结","categories":[{"name":"css","slug":"css","permalink":"http://zhanghy7.github.io/categories/css/"}],"tags":[]},{"title":"node包调试","slug":"node包调试","date":"2018-12-17T09:38:44.000Z","updated":"2018-12-25T08:36:02.552Z","comments":true,"path":"2018/12/17/node包调试/","link":"","permalink":"http://zhanghy7.github.io/2018/12/17/node包调试/","excerpt":"","text":"node包调试我们在开发node模块的时候一定会需要调试，那么都有哪些方式调试node模块呢？今天只谈现在的最新的调试方式: npm link软链方式进行新模块的使用(包括项目内的使用和直接使用模块)软链方式(npm link):https://github.com/atian25/blog/issues/17 模块调试vscode 跟上图这样配置好之后在代码中打断点，再到debugger模式这块点击“启动调试”即可。 这里launch.json中常用参数： args:命令行工具中传入的参数。 webStormrun=&gt;edit configuration 参考文献 vscode调试官方文档：https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/md/%E7%BC%96%E8%BE%91%E5%99%A8/%E8%B0%83%E8%AF%95.html http://blog.gejiawen.com/2016/09/21/make-a-node-cli-program-by-commander-js/ https://zhuanlan.zhihu.com/p/38520504 commanderjs","categories":[],"tags":[]},{"title":"计算机基础知识","slug":"计算机基础知识","date":"2018-12-17T03:18:00.000Z","updated":"2018-12-17T15:41:14.654Z","comments":true,"path":"2018/12/17/计算机基础知识/","link":"","permalink":"http://zhanghy7.github.io/2018/12/17/计算机基础知识/","excerpt":"","text":"计算机基础知识计算机存储与软硬链接 文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区可以存储512B大小的数据）。而操作系统读取文件按照块来读取（多个连续的扇区），也就是说操作系统读取文件的最小存取单位是块（block，通常是4KB）。 除了存储文件数据外，计算机还会存储文件的元信息（文件的大小、创建者、文件的时间戳、读写执行的权限等信息），这种存储文件元信息的结构就叫inode，我们可以使用stat来查看文件的元信息。每一个inode都有一个唯一的id，linux系统中通过inode的号码来识别文件。在linux中目录也是一种文件，该文件由inode和文件名组成。 查看目录文件的内容： 总结： 硬盘存取的基本单位是扇区(sector，512B)，系统存储的基本单位是块(block，4KB) 存储文件元信息的结构叫inode(存储文件的大小、时间戳、创建者、读写操作权限等信息)。 每个inode都有一个唯一的号码，系统用这个号码去识别文件。 linux中目录也是一种文件，由文件名和inode的id组成。 硬链接： 一般情况下一个文件名对应一个inode，但是linux允许多个文件名对应一个inode。这表示我们可以用不同的文件名去访问同一个文件，并且删除源文件不影响其他文件，修改源文件所有文件内容都被修改，这种机制就叫硬链接。 不能用于目录，只能用于文件。 命令：ln source target（把source指向target） 软链接： 新建了一个文件B，B拥有自己的inode，但是这个inode是指向源文件A的inode的，这个时候删除源文件，访问B时就说报“文件不存在”。 ​ 命令：ln -s source target（把source指向target） 创建一个软链接： 软链接可以用于文件和目录。npm link就是使用软链接的方式实现的(将模块别名aaa写入到/usr/local/bin中，而aaa指向实际的模块文件，全局执行aaa实际上就是在执行模块文件)。 Npm link原理： 总结 硬链接只能用于存在的文件，不能用于目录，并且所有硬链接的inode是一样的。 软链接可以用于文件、目录，软链接的inode都是不同的。 参考文献 http://taobaofed.org/blog/2016/07/29/puzzled-by-link/ https://github.com/atian25/blog/issues/17","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://zhanghy7.github.io/tags/计算机基础/"}]},{"title":"对全局node包的灵魂拷问","slug":"对全局node包的灵魂拷问","date":"2018-12-15T14:40:32.000Z","updated":"2018-12-16T02:39:30.359Z","comments":true,"path":"2018/12/15/对全局node包的灵魂拷问/","link":"","permalink":"http://zhanghy7.github.io/2018/12/15/对全局node包的灵魂拷问/","excerpt":"","text":"Why can you run anywhere after ‘npm i -g ‘? 我们经常在全局安装node包之后在任意的目录下都能顺利的执行该命令，比如node i -g nodeA，之后就可以在任意目录下使用nodeA这个命令，但这么神奇的现象是为什么呢？ 首先我们要知道什么命令才能在全局运行，这里就要涉及shell相关的知识了，其实是这样的：在linux系统中有这么几个地方的脚本是可以在任意目录下运行的： 全局安装后的node包的二进制脚本文件其实都存放在/usr/local/bin下，比我的所有的全局命令：","categories":[],"tags":[]},{"title":"liver-server搭建本地临时服务","slug":"liver-server搭建本地临时服务","date":"2018-12-14T09:39:09.000Z","updated":"2018-12-14T10:44:18.821Z","comments":true,"path":"2018/12/14/liver-server搭建本地临时服务/","link":"","permalink":"http://zhanghy7.github.io/2018/12/14/liver-server搭建本地临时服务/","excerpt":"","text":"live-server搭建本地临时服务 有时候我们需要开发一些临时的、非完整项目的静态文件,这个时候往往只能页面写好之后在浏览器中打开查看，并且在修改了文件之后得手动刷新页面才能看到效果，但是有没有一种方式让我们的临时文件也能像一个完整的项目去热更新呢？ 答案是有的，可以使用liver-server进行快速查看以及文件修改后浏览器的热更新。 live-server是什么它是一个简单的node app，它服务于工作目录及其子目录。启动之后就可以在浏览器中查看各个文件夹下的资源。 图示：","categories":[],"tags":[]},{"title":"commond is not found: mysql","slug":"commond-is-not-found-mysql","date":"2018-12-14T04:50:00.000Z","updated":"2018-12-14T09:33:31.594Z","comments":true,"path":"2018/12/14/commond-is-not-found-mysql/","link":"","permalink":"http://zhanghy7.github.io/2018/12/14/commond-is-not-found-mysql/","excerpt":"","text":"commond is not found: mysql背景设备：mac电脑。现象：安装mysql完毕后，在命令行中输入mysql提示commond is not found: mysql 原因 系统环境中没有添加mysql的全局环境变量。那么首先我们要知道全局的环境变量定义在哪里，以及其中的变量如何能够初始化被正常使用，其实电脑中会存在这么一个文件存储所有的全局环境变量，mac叫.bash_profile，在每次打开终端的时候这个文件会被执行，之后它里边定义的变量就可以在任何目录下执行了。 解决办法简单解决法 通过管理员的身份修改.bash_profile文件，在其中添加export PATH=$PATH:/usr/local/mysql/bin之后保存。 重启命令行工具或者在当前命令行中在运行source ~/.bash_profile即可生效。⚠️但是这种方式会在终端重启之后失效。升级解决法在/.zshrc文件中添加这个命令source ~/.bash_profile，因为每次终端在打开的时候都会执行这个文件。 参考文献 https://blog.csdn.net/yi412/article/details/11523525","categories":[{"name":"shell","slug":"shell","permalink":"http://zhanghy7.github.io/categories/shell/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://zhanghy7.github.io/tags/问题/"}]},{"title":"记一次git stash被误删之后找回的经历","slug":"记一次git-stash被误删之后找回的经历","date":"2018-12-12T09:19:00.000Z","updated":"2018-12-12T13:20:34.741Z","comments":true,"path":"2018/12/12/记一次git-stash被误删之后找回的经历/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/记一次git-stash被误删之后找回的经历/","excerpt":"","text":"记一次git stash被误删之后找回的经历⚠️⚠️⚠️长故事预警 事情是这样的，有一个公共组件需要开发，然后我就在一个正在开发新需求的分支feature/batch-1203上进行开发这个公共组件，一切都是那么顺利，组件写好了，自测也没问题。💔但是等到要把这个组件发到线上的一个新的用于公共组件存放的分支上的时候，在我自己的feature/batch-1203分支上找不到我所写的组件了！！！💔 解决git fsck –unreachable使用这个命令查看所有不可访问的对象。 打出来的输出如下： git show + 上图打出来的key（此处我是从后往前一个一个查的），用来查看每个阶段都修改了什么内容。 如下所示： git stash apply + 找到改动的key这样就能恢复丢掉的stash了 参考文献 https://linux.cn/article-8819-1.html https://www.jianshu.com/p/ae1987efec61","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://zhanghy7.github.io/tags/git/"},{"name":"问题及解决","slug":"问题及解决","permalink":"http://zhanghy7.github.io/tags/问题及解决/"}]},{"title":"js对象属性的控制","slug":"js对象的四个底层属性","date":"2018-12-12T06:46:00.000Z","updated":"2018-12-23T14:51:15.791Z","comments":true,"path":"2018/12/12/js对象的四个底层属性/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/js对象的四个底层属性/","excerpt":"","text":"js对象的六个底层属性js中有两个个可以修改或者定义对象属性的方法：defineProperty(object,name,discriptor)和defineProperties(object, props)。 defineProperty参数解释： object：要操作的对象 name：要定义或修改的属性的名称。 discriptor：是个对象，其中包含四个用于操作第二步中name的属性。 返回值： 被传递给函数的修改后的对象 下边分别看一下discriptor中都有哪四个属性，它们分别有什么作用： configurable这个属性用于控制此属性是否可被修改或删除，为true时候可被修改也可被删除，为false则相反。 默认为true enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的可枚举属性(for in, Object.keys()可遍历)中。默认为 true。 value属性值，可以为任何有效的值，默认为undefined writable控制value是否可被修改 get在访问这个属性时候返回的value值。 set在给这个属性赋值或者修改值时候会执行这个方法。 例子12345678910111213141516const person = &#123; name: 'Tom', age: 23&#125;console.log(person.name) // Tomconsole.log(Object.keys(person)) // [name,age]Object.defineProperty(person, 'name', &#123; configurable: false, enumerable: false, value: '', writable: true&#125;)console.log(person.name) //console.log(Object.keys(person)) // [age] 参考文献 MDN","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://zhanghy7.github.io/tags/js/"}]},{"title":"es6之修饰器","slug":"es6之修饰器","date":"2018-12-12T04:03:43.000Z","updated":"2018-12-12T06:48:49.637Z","comments":true,"path":"2018/12/12/es6之修饰器/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/es6之修饰器/","excerpt":"","text":"es6之修饰器类的修饰对类的修饰，这里的修饰器就是一个对类进行处理的 函数。 通过修饰器我们可以对类进行两种处理，分别是给类本身添加静态方法和给类添加实例方法： 12345678910// 给类添加静态方法function decorator (target) &#123; target.getName = function () &#123; console.log(target.name) &#125;&#125;@decoratorclass MyClass &#123;&#125;MyClass.getName() // MyClass 1234567891011// 给类添加实例方法function decorator (target) &#123; target.prototype.getName = function () &#123; console.log(target.name) &#125;&#125;@decoratorclass MyClass &#123;&#125;const newClass = new MyClass()newClass.getName() // MyClass 注意点：可以看到给类添加实例方法实际上就是给类的prototype上添加方法，这步操作可以使用Object.assign(MyClass.prototype, decorator)来模拟 方法的修饰","categories":[],"tags":[]},{"title":"mysql常用命令","slug":"mysql常用命令","date":"2018-12-10T10:20:00.000Z","updated":"2018-12-12T13:19:15.389Z","comments":true,"path":"2018/12/10/mysql常用命令/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mysql常用命令/","excerpt":"","text":"mysql常用命令因为我用的是mac，可能某些命令会跟windows上不一样。 启动、重启和关闭前提是通过命令行启动服务的才能通过命令行关闭和重启。 启动：/usr/local/mysql/support-files/mysql.server start```12重启：```sudo /usr/local/mysql/support-files/mysql.server restart 关闭：/usr/local/mysql/support-files/mysql.server stop```1234## 登录、退出本地登录： ```mysql -u root -p (以用户名root身份使用密码登录) 远程登录：mysql -h123.123.123.123 -u root -p 退出：exit","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhanghy7.github.io/tags/mysql/"}]},{"title":"mac命令行配置文件","slug":"mac命令行配置文件","date":"2018-12-10T10:03:37.000Z","updated":"2018-12-10T10:04:08.571Z","comments":true,"path":"2018/12/10/mac命令行配置文件/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mac命令行配置文件/","excerpt":"","text":"~/.bash_profile","categories":[],"tags":[]},{"title":"api接口管理系统之rap2","slug":"api接口管理系统之rap2","date":"2018-12-10T09:00:24.000Z","updated":"2018-12-10T09:00:56.113Z","comments":true,"path":"2018/12/10/api接口管理系统之rap2/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/api接口管理系统之rap2/","excerpt":"","text":"简书","categories":[],"tags":[]},{"title":"http之数据传输原理和content-type","slug":"http之数据传输原理和content-type","date":"2018-12-07T08:29:00.000Z","updated":"2018-12-12T04:03:09.650Z","comments":true,"path":"2018/12/07/http之数据传输原理和content-type/","link":"","permalink":"http://zhanghy7.github.io/2018/12/07/http之数据传输原理和content-type/","excerpt":"","text":"http之数据传输原理和content-type数据到底是以什么形式在网络中进行传输的？ 大家都知道，前后端通过数据请求和响应进行交互，进而完成整个网站功能。在这个过程中数据的传输就变得异常重要了，由此引发的困惑我许久的问题：“这个数据是以什么形式传递的呢？” 网上的解释是网络数据是以 http协议(超文本协议) 进行传输的，那么这个数据在传递过程中是以文本形式传输的吗？答案是非也，所有网络数据都是以二进制流进行传输的，至于我们捕获到的文本形式的的请求其实是二进制数据流经过编辑器等处理过的文本信息。 注意点：http的超级文本其实就是二进制在http协议中的存在形式 常见的请求方式HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中post请求通常用于文件的上传、表单的提交等向服务器端发送数据。 四种post请求的content-typeapplication/x-www-form-urlencoded这种方式是最常见的请求头，像ajax、以及浏览器原生的form表单提交默认请求头都是采用这种方式。 表现形式：一组属性名和属性值以=相连，不同属性之间以&amp;符号相连，和浏览器中的url组成方式一样。 图示： multipart/form-data这种方式通常用于文件、图片等的上传。 表现形式：由三部分组成：boundary+content+content-type(这个不一定都有，只有在上传文件的时候会有)。其中boundary是用于识别不同数据的分隔符，content-type是上传文件的文件类型。 图示： application/json这种方式现在普遍应用于非文件类型的数据提交。采用json格式传输数据是一种非常好的方式，这种方式不仅传输的数据量少，而且可以嵌套多层传递复杂的数据。 text/xml还有一种text/xml的古老的方式，谁有兴趣谁去研究一下吧zzz 参考文献 https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data post提交的四种方式 http的网络传输方式 fetch设置请求头","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://zhanghy7.github.io/tags/http/"}]},{"title":"非暴力沟通读书笔记一","slug":"非暴力沟通读书笔记一","date":"2018-12-06T13:06:00.000Z","updated":"2018-12-07T07:31:22.124Z","comments":true,"path":"2018/12/06/非暴力沟通读书笔记一/","link":"","permalink":"http://zhanghy7.github.io/2018/12/06/非暴力沟通读书笔记一/","excerpt":"","text":"非暴力沟通读书笔记一四要素非暴力沟通的要素：观察、感受、需要、要求。 我们在沟通过程中按照这四个方式把自己的想法完整的表达出来，这样的表达方式既能把自己的思想表达出来又能让对方明白你的需求，避免因为某一环节的缺失造成双方的沟通障碍，进而引发矛盾。 精彩故事片段 一位母亲对青春期的儿子说：“弗利克斯，看到咖啡桌角下你的两双脏袜子，我很不高兴，我更需要的是干净的环境，请你把它们放到洗衣机里去洗掉”。","categories":[],"tags":[]},{"title":"细说margin负值","slug":"细说margin负值","date":"2018-12-02T15:04:00.000Z","updated":"2018-12-06T07:03:59.621Z","comments":true,"path":"2018/12/02/细说margin负值/","link":"","permalink":"http://zhanghy7.github.io/2018/12/02/细说margin负值/","excerpt":"","text":"marginmargin作为css中最常用的属性之一，但是在使用过程中我发现对于margin的正值用的很顺畅，但是设置负值就会出现各种各样奇奇怪怪的现象，所以整理一份笔记帮助自己理解margin这个属性。 正值正值没什么好说的，哪个方向设多少就在哪个方向增加多少外边距。 负值这里主要整理一下负值的知识点。 基础知识margin的设置会影响元素的表现形式，那么我们首先要知道决定元素表现形式的三要素，这会对之后的知识点的理解有重大帮助： margin设置的方向 元素是否浮动 元素的定位方式具体表现形式元素无浮动无定位 敌不动我动：margin-top和margin-left为负，元素向该方向移动。 我不动敌动：margin-right和margin-bottom为负，该元素不动，该方向的相邻元素会移动相应的距离覆盖到该元素。 这种情况下如果元素没有设置宽度，那么设置了margin-left和margin-right之后元素的宽度会增加，和padding一个效果。未设置宽度、margin的图示：未设置宽度、设置margin的图示： 元素无浮动，定位为relative表现形式和无定位无浮动一致。 元素无浮动，定位为absolute margin-top和margin-left和无浮动无定位一样。 margin-right和margin-bottom无效果，因为脱离了文档流。 元素设置了浮动（float元素是包裹在他们的block元素中浮动的，不会超出父级block元素） 浮动方向和margin方向一致时，元素向相应的方向移动相应的距离。 浮动元素和margin方向不一致，元素本身不动，相邻元素向该元素移动相应的距离。 参考文章： 负margin用法权威指南","categories":[{"name":"css基础","slug":"css基础","permalink":"http://zhanghy7.github.io/categories/css基础/"}],"tags":[]},{"title":"专业英文单词学习","slug":"专业英文单词学习","date":"2018-11-30T06:01:00.000Z","updated":"2018-12-07T08:13:53.336Z","comments":true,"path":"2018/11/30/专业英文单词学习/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/专业英文单词学习/","excerpt":"","text":"英文单词 并行： parallel 阻塞： stalled 二进制：binary 堆：heap 队列：queue 栈：stack 进程：process 线程：thread 问题：issue 仪表盘：dashboard 用于文件内的字符串的查找：grep 形实转换程序：thunk 构成、组成：compose 回来的、回家的：redux 重构：refactor 章：chapter 账号：account 订阅：subscription 发布：publish 教程：tutorial 博客：blog 社区；团体：community 直到；就…而言：as far as 传说；冒险故事：saga 就…而言：in term of 语法：syntax 请求响应：request/response 任务：task 伪造：forgery CSRF(cross-site request forgery)：跨站点请求伪造 猜测：guess 移动：shift 作用域：scope 兼容：compatible 驾驶；解决： navigate 记录： record 持久化： persistant 数据结构：structure 观察者：observer 检查：inspect 冒泡: propagation bubble 修饰者: decorator 中间的；媒介: medium 局部的，偏爱的: partial 阶乘的: factorial 允许跨域: access-control-allow-origin 取： fetch 独一无二的: unique 概念: concept 预先装置的: preset 结合: combine （为小说等）写(续篇)： sequelize 权利：authority 检测到的: detected 小数的:decimal 被动的，消极的：passive 官方的：official 结合：integrate 标记：tick 部分：segment 别名：alias 平原；朴素的：plain","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://zhanghy7.github.io/tags/English/"}]},{"title":"软件架构模式","slug":"软件架构模式","date":"2018-11-30T06:00:00.000Z","updated":"2018-11-30T06:04:37.523Z","comments":true,"path":"2018/11/30/软件架构模式/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/软件架构模式/","excerpt":"","text":"软件架构模式MVC 特点：单向通信 MVVM 特点： view层和model层不再通信 view和viewModel层双向绑定，同时改变，无需专门触发 在前端来说各部分代表的是什么？Model数据（自定义的数据、服务器返回的数据） Viewhtml和css，用户能看到的东西 ViewModel连接view和Model的桥梁，数据视图双向绑定。","categories":[{"name":"宏观架构","slug":"宏观架构","permalink":"http://zhanghy7.github.io/categories/宏观架构/"}],"tags":[]},{"title":"vue使用笔记","slug":"vue使用笔记","date":"2018-11-30T05:59:00.000Z","updated":"2018-11-30T06:05:05.868Z","comments":true,"path":"2018/11/30/vue使用笔记/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/vue使用笔记/","excerpt":"","text":"vue使用计算属性和监听计算属性(computed)缓存特性和使用场景​ 依赖的数据变化时候此字段的数据跟着变化，所以这里就存在缓存的情况，如果依赖的数据没有变化，这时候这个数据本身也不变。 可以加setterclass和style属性​ vue为这两属性做了增强，本来v-bind绑定的只能是字符串，这里支持对象和数组。 class​ 可以与普通的class共存，可以同时写(自己之前的写法都是一次只用一个，以为不能混用。。。) ​ 对象可以写在属性里，也可以写在data中、computed中。 ​ 数组形式的话直接写字段名，最终渲染出来是字段对应的值。 ###style ​ 支持驼峰命名和短横线命名。 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 1234data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; ​ 当使用:style的时候，vue会自动添加浏览器需要的前缀。 ​ 可以给一个css属性绑定多个值，放在一个数组中，这样就只会渲染浏览器支持的最后一个值。 vue.filter过滤器，用于处理一些转义等字段。 使用全局123Vue.filter(&apos;test&apos;,function(value)&#123;return value + &apos;test&apos;&#125;);&#123;&#123;msg | test&#125;&#125;&lt;input v-model=&quot;msg | test&quot;/&gt; 局部在组件内部添加filter属性 class对象写法数组写法访问数据及方法只有写在template里边默认是在当前组件内取值，不用加this 子组件中的data不跟随props变化而变化data中的值只会在组件第一次初始化数据时候执行一次，并不会跟随props的变化而变化。 想要响应式变化就需要用到computed和watch。 事件监听使用（模板非字符串模板）不同于组件和props，事件名不会被用作一个js变量名或属性名，所以没有理由使用camelCase或pascalCase命名。事件监听器在DOM模板中都会转为小写的，因为html不区分大小写。推荐使用kebab-case命名方式。 props中有对象子组件可以直接修改对象内的值装修助手量房端详情页采用这种方式进行修改 vue生命周期执行过程12每种生命周期由父组件向子组件执行，接着在执行下一个生命周期，比如会先执行所有的created函数之后再执行mounted函数。但是如果哪个组件的生成需要依赖异步请求的数据，这个规则不适用。一般来说它会在其他父组件加载完成之后按照生命周期顺序执行自己的生命周期 注意事项生命周期函数不支持async因为整个 diff 和 render 的算法都是基于组件生命周期同步执行的前提下的。而且任意一个组件的生命周期可能异步推迟最后的渲染完成是绝对不应该出现的设计。github问题地址 css作用域问题​ vue-cli命令提供了两种内置的解决css样式覆盖问题的方案，scoped和css modules。 scoped使用​ 简单易用，在style标签内写上scoped属性即可。 原理​ 为class名称后边添加data-xxxx这样一串字符串用来确保css样式的唯一。 缺点1. 若父组件和子组件有同名class，那么父组件设置的样式还会作用于子组件。 2. 对v-html中的元素设置的样式是不生效的。 css modules​ 需要使用vue-cli3生成项目脚手架才能直接用，否则需要自己配置webpack。 配置webpack很简单，就是在css-loader后边加个?modules打开css modules。 loader: &#39;css-loader?modules&#39;, 使用​ style标签中添加module属性，但是在class中需要通过$style.xxx来设置样式 &lt;div :class=&quot;$style.test&quot;&gt;&lt;/div&gt; 原理​ 将每个css名称编译成为唯一的字符串 缺点​ 使用复杂，所有样式都要通过$style操作 优点 名称唯一 可以显示的使用$style去操作css，甚至是在钩子函数中进行操作。 ​","categories":[{"name":"vue","slug":"vue","permalink":"http://zhanghy7.github.io/categories/vue/"}],"tags":[]},{"title":"hybrid","slug":"hybrid","date":"2018-11-30T05:58:00.000Z","updated":"2018-11-30T06:05:48.176Z","comments":true,"path":"2018/11/30/hybrid/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/hybrid/","excerpt":"","text":"hybrid特征 可用的系统、网络资源和web app有本质的区别。 支持更新的浏览器特性。 可实现离线应用。利用h5的缓存机制和native自身的文件写入。 需要兼容多版本多机型的设备。 可以调用native的原生功能。","categories":[{"name":"hybrid","slug":"hybrid","permalink":"http://zhanghy7.github.io/categories/hybrid/"}],"tags":[]},{"title":"es6-class","slug":"es6-class","date":"2018-11-30T05:57:00.000Z","updated":"2018-11-30T06:06:25.250Z","comments":true,"path":"2018/11/30/es6-class/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/es6-class/","excerpt":"","text":"es6class​ js提供的一个语法糖，用来更清晰的定义类，有constructor属性，constructor里边定义类的属性，constructor默认返回实例对象（即this），但也可以返回其他对象。 ​ 它的方法都挂在prototype上。 示例代码如下： Point &#123;1234567891011121314151617181920 constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; set、get关键字在class内部可以使用set和get关键字，对某个属性设置存值函数和取值函数,示例代码： Super&#123;123456789101112131415constructor(name,age) &#123; this.name = name this.test = age&#125;set age(value) &#123; this.test = value +1&#125;get age() &#123; return this.test &#125;&#125;var obj = new Super(&apos;aaa&apos;,2)console.log(obj.age) // 2obj.age = 4console.log(obj.age) // 5 静态方法和私有方法属性​ 有静态方法，没有私有属性和私有方法，但可以通过其他方式实现，比如symbol。 静态方法​ 有关键字static的方法不能被实例继承，而是通过类直接调用，这种方法就叫”静态方法“。(静态方法可以和非静态方法重名；如果静态方法中有this关键字，那么这个this代表的是类，而非类的实例) 私有属性​ 类本身的属性，而不是通过constructor挂载实例this上的属性，比如Super.props = 1. 目前有了提案： 可以直接加关键字static定义静态属性 实例属性可以不用必须写在constructor中了。 新增属性new.target​ 新增属性new.target，用在构造函数中，用来判断实例对象是否通过new关键字来创建的，还有一种方法判断就是this instanceof Person 对比es5很多特性都和es5是一致的，但有些特性就不同： 1. 类的内部所有定义的方法都是不可枚举的。 2. 默认就是严格模式。在类或者模块内部，默认就是严格模式。 3. 必须使用new进行调用，否则会报错。 4. 没有变量提升。 原型相关API hasOwnProperty用来判断对象是否自身拥有某属性。 getPrototypeOf方法可以用来判断类的继承关系；.proto属性的替代方法，获取对象的原型。 Object.keys是遍历不到prototype的，它只遍历可枚举的自身属性。 Object.getOwnPropertyNames返回对象所有可枚举不可枚举的属性和方法。 继承es5和es6es5原型链只有一条，即prototype； es6原型链有两条，一条是类本身实现属性继承(这样就子类就可以继承父类的静态方法)，相当于是es5中的call/apply，另一条才是prototype。 内部对象没有静态引用。 ​ 子类的this需要通过父类的constructor完成塑造，得到与父类同样的实例属性和方法，然后在对其进行加工，否则子类是得不到this对象的。 getPrototypeOf()​ 判断继承关系 super​ 既可以当函数使用也可以当对象使用。 super()调用父类构造函数；super.method()调用父类方法 作为函数代表的是父类的构造函数，内部this指向的是子类。只能用在子类的构造函数中。 super() = A.prototype.constructor.call(this) 作为对象，在普通方法中指向的是父类的原型对象（不能访问父类的，this指向子类实例），在静态方法中指向的是父类（this指向子类）。 使用地方可以用在class中和对象属性为method()中。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://zhanghy7.github.io/categories/javaScript/"},{"name":"es6","slug":"javaScript/es6","permalink":"http://zhanghy7.github.io/categories/javaScript/es6/"}],"tags":[]},{"title":"搭建个人博客(hexo)","slug":"搭建个人博客-hexo","date":"2018-11-29T06:32:28.000Z","updated":"2018-11-29T08:11:27.072Z","comments":true,"path":"2018/11/29/搭建个人博客-hexo/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/搭建个人博客-hexo/","excerpt":"","text":"使用hexo+git page搭建自己的博客新建项目前提是自己需要新建自己的git page，在下边的第三步进行关联。 npm install -g hexo-cli hexo init myBlog 进入项目找到_config.yml文件，修改配置： 安装git部署插件：npm install hexo-deployer-git –save 启动本地项目：hexo server 自选主题 主题在线查看传送门 选好主题后进入myBlog下载主题。例如:git clone https://github.com/levblanc/hexo-theme-aero-dual.git themes/aero-dual 重启本地服务查看主题：hexo server个性化修改主题一般来说我们都要修改主题，让它变成我们自己的内容： 修改主题中的_config.yml文件后（注意这里一定得是这个主题里的配置文件，在themes），就可以生成自己的主页了。 配置文件长这样：试用了一个主题长这个样子： 其中遇到的坑点： 配置文件中的主题图片在哪里？ 写作并发布写作这块使用hexo-admin进行博客管理，具体使用方式如下： 进入项目myBlog安装hexo-admin包： npm i hexo-admin --save 启动项目，并进入localhost:4000/admin，就可以看到博客管理界面。 在posts下就可以新增页面进行文件编辑了 （page和posts布局有什么区别还有待研究） 原理分析从编辑md到转为html，再到部署（包括部署地址）","categories":[],"tags":[]},{"title":"webStorm主题设置","slug":"webStorm主题设置","date":"2018-11-29T03:27:00.000Z","updated":"2018-11-29T03:34:59.413Z","comments":true,"path":"2018/11/29/webStorm主题设置/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/webStorm主题设置/","excerpt":"","text":"webStorm主题设置 一、下载主题 两个地址： webStormThemes color Themes 二、导入主题 File-&gt;Import Setting 选择自己下载的主题（jar包）后导入即可","categories":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/tags/tools/"}]}]}