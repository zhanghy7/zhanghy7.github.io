{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"zhanghy7","url":"http://zhanghy7.github.io"},"pages":[],"posts":[{"title":"node包调试","slug":"node包调试","date":"2018-12-17T09:38:44.000Z","updated":"2018-12-17T14:42:05.402Z","comments":true,"path":"2018/12/17/node包调试/","link":"","permalink":"http://zhanghy7.github.io/2018/12/17/node包调试/","excerpt":"","text":"node包调试我们在开发node模块的时候一定会需要调试，那么都有哪些方式调试node模块呢？今天只谈现在的最新的调试方式: npm link软链方式进行新模块的使用(包括项目内的使用和直接使用模块)软链方式(npm link):https://github.com/atian25/blog/issues/17 模块调试vscode 跟上图这样配置好之后在代码中打断点，再到debugger模式这块点击“启动调试”即可。 这里launch.json中常用参数： args:命令行工具中传入的参数。 webStormrun=&gt;edit configuration 参考文献 vscode调试官方文档：https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/md/%E7%BC%96%E8%BE%91%E5%99%A8/%E8%B0%83%E8%AF%95.html","categories":[],"tags":[]},{"title":"计算机基础知识","slug":"计算机基础知识","date":"2018-12-17T03:18:58.000Z","updated":"2018-12-17T15:39:24.123Z","comments":true,"path":"2018/12/17/计算机基础知识/","link":"","permalink":"http://zhanghy7.github.io/2018/12/17/计算机基础知识/","excerpt":"","text":"计算机基础知识计算机存储与软硬链接 文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区可以存储512B大小的数据）。而操作系统读取文件按照块来读取（多个连续的扇区），也就是说操作系统读取文件的最小存取单位是块（block，通常是4KB）。 除了存储文件数据外，计算机还会存储文件的元信息（文件的大小、创建者、文件的时间戳、读写执行的权限等信息），这种存储文件元信息的结构就叫inode，我们可以使用stat来查看文件的元信息。每一个inode都有一个唯一的id，linux系统中通过inode的号码来识别文件。在linux中目录也是一种文件，该文件由inode和文件名组成。 查看目录文件的内容： 总结： 硬盘存取的基本单位是扇区(sector，512B)，系统存储的基本单位是块(block，4KB) 存储文件元信息的结构叫inode(存储文件的大小、时间戳、创建者、读写操作权限等信息)。 每个inode都有一个唯一的号码，系统用这个号码去识别文件。 linux中目录也是一种文件，由文件名和inode的id组成。 硬链接： 一般情况下一个文件名对应一个inode，但是linux允许多个文件名对应一个inode。这表示我们可以用不同的文件名去访问同一个文件，并且删除源文件不影响其他文件，修改源文件所有文件内容都被修改，这种机制就叫硬链接。 不能用于目录，只能用于文件。 命令：ln source target（把source指向target） 软链接： 新建了一个文件B，B拥有自己的inode，但是这个inode是指向源文件A的inode的，这个时候删除源文件，访问B时就说报“文件不存在”。 ​ 命令：ln -s source target（把source指向target） 创建一个软链接： 软链接可以用于文件和目录。npm link就是使用软链接的方式实现的(将模块别名aaa写入到/usr/local/bin中，而aaa指向实际的模块文件，全局执行aaa实际上就是在执行模块文件)。 Npm link原理： 总结 硬链接只能用于存在的文件，不能用于目录，并且所有硬链接的inode是一样的。 软链接可以用于文件、目录，软链接的inode都是不同的。 参考文献 http://taobaofed.org/blog/2016/07/29/puzzled-by-link/ https://github.com/atian25/blog/issues/17","categories":[],"tags":[]},{"title":"对全局node包的灵魂拷问","slug":"对全局node包的灵魂拷问","date":"2018-12-15T14:40:32.000Z","updated":"2018-12-16T02:39:30.359Z","comments":true,"path":"2018/12/15/对全局node包的灵魂拷问/","link":"","permalink":"http://zhanghy7.github.io/2018/12/15/对全局node包的灵魂拷问/","excerpt":"","text":"Why can you run anywhere after ‘npm i -g ‘? 我们经常在全局安装node包之后在任意的目录下都能顺利的执行该命令，比如node i -g nodeA，之后就可以在任意目录下使用nodeA这个命令，但这么神奇的现象是为什么呢？ 首先我们要知道什么命令才能在全局运行，这里就要涉及shell相关的知识了，其实是这样的：在linux系统中有这么几个地方的脚本是可以在任意目录下运行的： 全局安装后的node包的二进制脚本文件其实都存放在/usr/local/bin下，比我的所有的全局命令：","categories":[],"tags":[]},{"title":"liver-server搭建本地临时服务","slug":"liver-server搭建本地临时服务","date":"2018-12-14T09:39:09.000Z","updated":"2018-12-14T10:44:18.821Z","comments":true,"path":"2018/12/14/liver-server搭建本地临时服务/","link":"","permalink":"http://zhanghy7.github.io/2018/12/14/liver-server搭建本地临时服务/","excerpt":"","text":"live-server搭建本地临时服务 有时候我们需要开发一些临时的、非完整项目的静态文件,这个时候往往只能页面写好之后在浏览器中打开查看，并且在修改了文件之后得手动刷新页面才能看到效果，但是有没有一种方式让我们的临时文件也能像一个完整的项目去热更新呢？ 答案是有的，可以使用liver-server进行快速查看以及文件修改后浏览器的热更新。 live-server是什么它是一个简单的node app，它服务于工作目录及其子目录。启动之后就可以在浏览器中查看各个文件夹下的资源。 图示：","categories":[],"tags":[]},{"title":"commond is not found: mysql","slug":"commond-is-not-found-mysql","date":"2018-12-14T04:50:00.000Z","updated":"2018-12-14T09:33:31.594Z","comments":true,"path":"2018/12/14/commond-is-not-found-mysql/","link":"","permalink":"http://zhanghy7.github.io/2018/12/14/commond-is-not-found-mysql/","excerpt":"","text":"commond is not found: mysql背景设备：mac电脑。现象：安装mysql完毕后，在命令行中输入mysql提示commond is not found: mysql 原因 系统环境中没有添加mysql的全局环境变量。那么首先我们要知道全局的环境变量定义在哪里，以及其中的变量如何能够初始化被正常使用，其实电脑中会存在这么一个文件存储所有的全局环境变量，mac叫.bash_profile，在每次打开终端的时候这个文件会被执行，之后它里边定义的变量就可以在任何目录下执行了。 解决办法简单解决法 通过管理员的身份修改.bash_profile文件，在其中添加export PATH=$PATH:/usr/local/mysql/bin之后保存。 重启命令行工具或者在当前命令行中在运行source ~/.bash_profile即可生效。⚠️但是这种方式会在终端重启之后失效。升级解决法在/.zshrc文件中添加这个命令source ~/.bash_profile，因为每次终端在打开的时候都会执行这个文件。 参考文献 https://blog.csdn.net/yi412/article/details/11523525","categories":[{"name":"shell","slug":"shell","permalink":"http://zhanghy7.github.io/categories/shell/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://zhanghy7.github.io/tags/问题/"}]},{"title":"记一次git stash被误删之后找回的经历","slug":"记一次git-stash被误删之后找回的经历","date":"2018-12-12T09:19:00.000Z","updated":"2018-12-12T13:20:34.741Z","comments":true,"path":"2018/12/12/记一次git-stash被误删之后找回的经历/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/记一次git-stash被误删之后找回的经历/","excerpt":"","text":"记一次git stash被误删之后找回的经历⚠️⚠️⚠️长故事预警 事情是这样的，有一个公共组件需要开发，然后我就在一个正在开发新需求的分支feature/batch-1203上进行开发这个公共组件，一切都是那么顺利，组件写好了，自测也没问题。💔但是等到要把这个组件发到线上的一个新的用于公共组件存放的分支上的时候，在我自己的feature/batch-1203分支上找不到我所写的组件了！！！💔 解决git fsck –unreachable使用这个命令查看所有不可访问的对象。 打出来的输出如下： git show + 上图打出来的key（此处我是从后往前一个一个查的），用来查看每个阶段都修改了什么内容。 如下所示： git stash apply + 找到改动的key这样就能恢复丢掉的stash了 参考文献 https://linux.cn/article-8819-1.html https://www.jianshu.com/p/ae1987efec61","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://zhanghy7.github.io/tags/git/"},{"name":"问题及解决","slug":"问题及解决","permalink":"http://zhanghy7.github.io/tags/问题及解决/"}]},{"title":"js对象属性的控制","slug":"js对象的四个底层属性","date":"2018-12-12T06:46:00.000Z","updated":"2018-12-12T13:18:19.453Z","comments":true,"path":"2018/12/12/js对象的四个底层属性/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/js对象的四个底层属性/","excerpt":"","text":"js对象的六个底层属性js中有两个个可以修改或者定义对象属性的方法：defineProperty(object,name,discriptor)和defineProperties(object, props)。 defineProperty参数解释： object：要操作的对象 name：要定义或修改的属性的名称。 discriptor：是个对象，其中包含四个用于操作第二步中name的属性。 返回值： 被传递给函数的修改后的对象 下边分别看一下discriptor中都有哪四个属性，它们分别有什么作用： configurable这个属性用于控制此属性是否可被修改或删除，为true时候可被修改也可被删除，为false则相反。 默认为true enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的可枚举属性(for in, Object.keys()可遍历)中。默认为 true。 value属性值，可以为任何有效的值，默认为undefined writable控制value是否可被修改 get在访问这个属性时候返回的value值。 set在给这个属性赋值或者修改值时候会执行这个方法。 例子12345678910111213141516const person = &#123; name: 'Tom', age: 23&#125;console.log(person.name) // Tomconsole.log(Object.keys(person)) // [name,age]Object.defineProperty(person, 'name', &#123; configurable: false, enumerable: false, value: '', writable: true&#125;)console.log(person.name) //console.log(Object.keys(person)) // [age] 参考文献 MDN","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zhanghy7.github.io/tags/javascript/"}]},{"title":"es6之修饰器","slug":"es6之修饰器","date":"2018-12-12T04:03:43.000Z","updated":"2018-12-12T06:48:49.637Z","comments":true,"path":"2018/12/12/es6之修饰器/","link":"","permalink":"http://zhanghy7.github.io/2018/12/12/es6之修饰器/","excerpt":"","text":"es6之修饰器类的修饰对类的修饰，这里的修饰器就是一个对类进行处理的 函数。 通过修饰器我们可以对类进行两种处理，分别是给类本身添加静态方法和给类添加实例方法： 12345678910// 给类添加静态方法function decorator (target) &#123; target.getName = function () &#123; console.log(target.name) &#125;&#125;@decoratorclass MyClass &#123;&#125;MyClass.getName() // MyClass 1234567891011// 给类添加实例方法function decorator (target) &#123; target.prototype.getName = function () &#123; console.log(target.name) &#125;&#125;@decoratorclass MyClass &#123;&#125;const newClass = new MyClass()newClass.getName() // MyClass 注意点：可以看到给类添加实例方法实际上就是给类的prototype上添加方法，这步操作可以使用Object.assign(MyClass.prototype, decorator)来模拟 方法的修饰","categories":[],"tags":[]},{"title":"mysql常用命令","slug":"mysql常用命令","date":"2018-12-10T10:20:00.000Z","updated":"2018-12-12T13:19:15.389Z","comments":true,"path":"2018/12/10/mysql常用命令/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mysql常用命令/","excerpt":"","text":"mysql常用命令因为我用的是mac，可能某些命令会跟windows上不一样。 启动、重启和关闭前提是通过命令行启动服务的才能通过命令行关闭和重启。 启动：/usr/local/mysql/support-files/mysql.server start```12重启：```sudo /usr/local/mysql/support-files/mysql.server restart 关闭：/usr/local/mysql/support-files/mysql.server stop```1234## 登录、退出本地登录： ```mysql -u root -p (以用户名root身份使用密码登录) 远程登录：mysql -h123.123.123.123 -u root -p 退出：exit","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zhanghy7.github.io/tags/mysql/"}]},{"title":"mac命令行配置文件","slug":"mac命令行配置文件","date":"2018-12-10T10:03:37.000Z","updated":"2018-12-10T10:04:08.571Z","comments":true,"path":"2018/12/10/mac命令行配置文件/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mac命令行配置文件/","excerpt":"","text":"~/.bash_profile","categories":[],"tags":[]},{"title":"api接口管理系统之rap2","slug":"api接口管理系统之rap2","date":"2018-12-10T09:00:24.000Z","updated":"2018-12-10T09:00:56.113Z","comments":true,"path":"2018/12/10/api接口管理系统之rap2/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/api接口管理系统之rap2/","excerpt":"","text":"简书","categories":[],"tags":[]},{"title":"http之数据传输原理和content-type","slug":"http之数据传输原理和content-type","date":"2018-12-07T08:29:00.000Z","updated":"2018-12-12T04:03:09.650Z","comments":true,"path":"2018/12/07/http之数据传输原理和content-type/","link":"","permalink":"http://zhanghy7.github.io/2018/12/07/http之数据传输原理和content-type/","excerpt":"","text":"http之数据传输原理和content-type数据到底是以什么形式在网络中进行传输的？ 大家都知道，前后端通过数据请求和响应进行交互，进而完成整个网站功能。在这个过程中数据的传输就变得异常重要了，由此引发的困惑我许久的问题：“这个数据是以什么形式传递的呢？” 网上的解释是网络数据是以 http协议(超文本协议) 进行传输的，那么这个数据在传递过程中是以文本形式传输的吗？答案是非也，所有网络数据都是以二进制流进行传输的，至于我们捕获到的文本形式的的请求其实是二进制数据流经过编辑器等处理过的文本信息。 注意点：http的超级文本其实就是二进制在http协议中的存在形式 常见的请求方式HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中post请求通常用于文件的上传、表单的提交等向服务器端发送数据。 四种post请求的content-typeapplication/x-www-form-urlencoded这种方式是最常见的请求头，像ajax、以及浏览器原生的form表单提交默认请求头都是采用这种方式。 表现形式：一组属性名和属性值以=相连，不同属性之间以&amp;符号相连，和浏览器中的url组成方式一样。 图示： multipart/form-data这种方式通常用于文件、图片等的上传。 表现形式：由三部分组成：boundary+content+content-type(这个不一定都有，只有在上传文件的时候会有)。其中boundary是用于识别不同数据的分隔符，content-type是上传文件的文件类型。 图示： application/json这种方式现在普遍应用于非文件类型的数据提交。采用json格式传输数据是一种非常好的方式，这种方式不仅传输的数据量少，而且可以嵌套多层传递复杂的数据。 text/xml还有一种text/xml的古老的方式，谁有兴趣谁去研究一下吧zzz 参考文献 https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data post提交的四种方式 http的网络传输方式 fetch设置请求头","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://zhanghy7.github.io/tags/http/"}]},{"title":"非暴力沟通读书笔记一","slug":"非暴力沟通读书笔记一","date":"2018-12-06T13:06:00.000Z","updated":"2018-12-07T07:31:22.124Z","comments":true,"path":"2018/12/06/非暴力沟通读书笔记一/","link":"","permalink":"http://zhanghy7.github.io/2018/12/06/非暴力沟通读书笔记一/","excerpt":"","text":"非暴力沟通读书笔记一四要素非暴力沟通的要素：观察、感受、需要、要求。 我们在沟通过程中按照这四个方式把自己的想法完整的表达出来，这样的表达方式既能把自己的思想表达出来又能让对方明白你的需求，避免因为某一环节的缺失造成双方的沟通障碍，进而引发矛盾。 精彩故事片段 一位母亲对青春期的儿子说：“弗利克斯，看到咖啡桌角下你的两双脏袜子，我很不高兴，我更需要的是干净的环境，请你把它们放到洗衣机里去洗掉”。","categories":[],"tags":[]},{"title":"细说margin负值","slug":"细说margin负值","date":"2018-12-02T15:04:00.000Z","updated":"2018-12-06T07:03:59.621Z","comments":true,"path":"2018/12/02/细说margin负值/","link":"","permalink":"http://zhanghy7.github.io/2018/12/02/细说margin负值/","excerpt":"","text":"marginmargin作为css中最常用的属性之一，但是在使用过程中我发现对于margin的正值用的很顺畅，但是设置负值就会出现各种各样奇奇怪怪的现象，所以整理一份笔记帮助自己理解margin这个属性。 正值正值没什么好说的，哪个方向设多少就在哪个方向增加多少外边距。 负值这里主要整理一下负值的知识点。 基础知识margin的设置会影响元素的表现形式，那么我们首先要知道决定元素表现形式的三要素，这会对之后的知识点的理解有重大帮助： margin设置的方向 元素是否浮动 元素的定位方式具体表现形式元素无浮动无定位 敌不动我动：margin-top和margin-left为负，元素向该方向移动。 我不动敌动：margin-right和margin-bottom为负，该元素不动，该方向的相邻元素会移动相应的距离覆盖到该元素。 这种情况下如果元素没有设置宽度，那么设置了margin-left和margin-right之后元素的宽度会增加，和padding一个效果。未设置宽度、margin的图示：未设置宽度、设置margin的图示： 元素无浮动，定位为relative表现形式和无定位无浮动一致。 元素无浮动，定位为absolute margin-top和margin-left和无浮动无定位一样。 margin-right和margin-bottom无效果，因为脱离了文档流。 元素设置了浮动（float元素是包裹在他们的block元素中浮动的，不会超出父级block元素） 浮动方向和margin方向一致时，元素向相应的方向移动相应的距离。 浮动元素和margin方向不一致，元素本身不动，相邻元素向该元素移动相应的距离。 参考文章： 负margin用法权威指南","categories":[{"name":"css基础","slug":"css基础","permalink":"http://zhanghy7.github.io/categories/css基础/"}],"tags":[]},{"title":"专业英文单词学习","slug":"专业英文单词学习","date":"2018-11-30T06:01:00.000Z","updated":"2018-12-07T08:13:53.336Z","comments":true,"path":"2018/11/30/专业英文单词学习/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/专业英文单词学习/","excerpt":"","text":"英文单词 并行： parallel 阻塞： stalled 二进制：binary 堆：heap 队列：queue 栈：stack 进程：process 线程：thread 问题：issue 仪表盘：dashboard 用于文件内的字符串的查找：grep 形实转换程序：thunk 构成、组成：compose 回来的、回家的：redux 重构：refactor 章：chapter 账号：account 订阅：subscription 发布：publish 教程：tutorial 博客：blog 社区；团体：community 直到；就…而言：as far as 传说；冒险故事：saga 就…而言：in term of 语法：syntax 请求响应：request/response 任务：task 伪造：forgery CSRF(cross-site request forgery)：跨站点请求伪造 猜测：guess 移动：shift 作用域：scope 兼容：compatible 驾驶；解决： navigate 记录： record 持久化： persistant 数据结构：structure 观察者：observer 检查：inspect 冒泡: propagation bubble 修饰者: decorator 中间的；媒介: medium 局部的，偏爱的: partial 阶乘的: factorial 允许跨域: access-control-allow-origin 取： fetch 独一无二的: unique 概念: concept 预先装置的: preset 结合: combine （为小说等）写(续篇)： sequelize 权利：authority 检测到的: detected 小数的:decimal 被动的，消极的：passive 官方的：official 结合：integrate 标记：tick 部分：segment 别名：alias 平原；朴素的：plain","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://zhanghy7.github.io/tags/English/"}]},{"title":"软件架构模式","slug":"软件架构模式","date":"2018-11-30T06:00:00.000Z","updated":"2018-11-30T06:04:37.523Z","comments":true,"path":"2018/11/30/软件架构模式/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/软件架构模式/","excerpt":"","text":"软件架构模式MVC 特点：单向通信 MVVM 特点： view层和model层不再通信 view和viewModel层双向绑定，同时改变，无需专门触发 在前端来说各部分代表的是什么？Model数据（自定义的数据、服务器返回的数据） Viewhtml和css，用户能看到的东西 ViewModel连接view和Model的桥梁，数据视图双向绑定。","categories":[{"name":"宏观架构","slug":"宏观架构","permalink":"http://zhanghy7.github.io/categories/宏观架构/"}],"tags":[]},{"title":"vue使用笔记","slug":"vue使用笔记","date":"2018-11-30T05:59:00.000Z","updated":"2018-11-30T06:05:05.868Z","comments":true,"path":"2018/11/30/vue使用笔记/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/vue使用笔记/","excerpt":"","text":"vue使用计算属性和监听计算属性(computed)缓存特性和使用场景​ 依赖的数据变化时候此字段的数据跟着变化，所以这里就存在缓存的情况，如果依赖的数据没有变化，这时候这个数据本身也不变。 可以加setterclass和style属性​ vue为这两属性做了增强，本来v-bind绑定的只能是字符串，这里支持对象和数组。 class​ 可以与普通的class共存，可以同时写(自己之前的写法都是一次只用一个，以为不能混用。。。) ​ 对象可以写在属性里，也可以写在data中、computed中。 ​ 数组形式的话直接写字段名，最终渲染出来是字段对应的值。 ###style ​ 支持驼峰命名和短横线命名。 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 1234data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; ​ 当使用:style的时候，vue会自动添加浏览器需要的前缀。 ​ 可以给一个css属性绑定多个值，放在一个数组中，这样就只会渲染浏览器支持的最后一个值。 vue.filter过滤器，用于处理一些转义等字段。 使用全局123Vue.filter(&apos;test&apos;,function(value)&#123;return value + &apos;test&apos;&#125;);&#123;&#123;msg | test&#125;&#125;&lt;input v-model=&quot;msg | test&quot;/&gt; 局部在组件内部添加filter属性 class对象写法数组写法访问数据及方法只有写在template里边默认是在当前组件内取值，不用加this 子组件中的data不跟随props变化而变化data中的值只会在组件第一次初始化数据时候执行一次，并不会跟随props的变化而变化。 想要响应式变化就需要用到computed和watch。 事件监听使用（模板非字符串模板）不同于组件和props，事件名不会被用作一个js变量名或属性名，所以没有理由使用camelCase或pascalCase命名。事件监听器在DOM模板中都会转为小写的，因为html不区分大小写。推荐使用kebab-case命名方式。 props中有对象子组件可以直接修改对象内的值装修助手量房端详情页采用这种方式进行修改 vue生命周期执行过程12每种生命周期由父组件向子组件执行，接着在执行下一个生命周期，比如会先执行所有的created函数之后再执行mounted函数。但是如果哪个组件的生成需要依赖异步请求的数据，这个规则不适用。一般来说它会在其他父组件加载完成之后按照生命周期顺序执行自己的生命周期 注意事项生命周期函数不支持async因为整个 diff 和 render 的算法都是基于组件生命周期同步执行的前提下的。而且任意一个组件的生命周期可能异步推迟最后的渲染完成是绝对不应该出现的设计。github问题地址 css作用域问题​ vue-cli命令提供了两种内置的解决css样式覆盖问题的方案，scoped和css modules。 scoped使用​ 简单易用，在style标签内写上scoped属性即可。 原理​ 为class名称后边添加data-xxxx这样一串字符串用来确保css样式的唯一。 缺点1. 若父组件和子组件有同名class，那么父组件设置的样式还会作用于子组件。 2. 对v-html中的元素设置的样式是不生效的。 css modules​ 需要使用vue-cli3生成项目脚手架才能直接用，否则需要自己配置webpack。 配置webpack很简单，就是在css-loader后边加个?modules打开css modules。 loader: &#39;css-loader?modules&#39;, 使用​ style标签中添加module属性，但是在class中需要通过$style.xxx来设置样式 &lt;div :class=&quot;$style.test&quot;&gt;&lt;/div&gt; 原理​ 将每个css名称编译成为唯一的字符串 缺点​ 使用复杂，所有样式都要通过$style操作 优点 名称唯一 可以显示的使用$style去操作css，甚至是在钩子函数中进行操作。 ​","categories":[{"name":"vue","slug":"vue","permalink":"http://zhanghy7.github.io/categories/vue/"}],"tags":[]},{"title":"hybrid","slug":"hybrid","date":"2018-11-30T05:58:00.000Z","updated":"2018-11-30T06:05:48.176Z","comments":true,"path":"2018/11/30/hybrid/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/hybrid/","excerpt":"","text":"hybrid特征 可用的系统、网络资源和web app有本质的区别。 支持更新的浏览器特性。 可实现离线应用。利用h5的缓存机制和native自身的文件写入。 需要兼容多版本多机型的设备。 可以调用native的原生功能。","categories":[{"name":"hybrid","slug":"hybrid","permalink":"http://zhanghy7.github.io/categories/hybrid/"}],"tags":[]},{"title":"es6-class","slug":"es6-class","date":"2018-11-30T05:57:00.000Z","updated":"2018-11-30T06:06:25.250Z","comments":true,"path":"2018/11/30/es6-class/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/es6-class/","excerpt":"","text":"es6class​ js提供的一个语法糖，用来更清晰的定义类，有constructor属性，constructor里边定义类的属性，constructor默认返回实例对象（即this），但也可以返回其他对象。 ​ 它的方法都挂在prototype上。 示例代码如下： Point &#123;1234567891011121314151617181920 constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; set、get关键字在class内部可以使用set和get关键字，对某个属性设置存值函数和取值函数,示例代码： Super&#123;123456789101112131415constructor(name,age) &#123; this.name = name this.test = age&#125;set age(value) &#123; this.test = value +1&#125;get age() &#123; return this.test &#125;&#125;var obj = new Super(&apos;aaa&apos;,2)console.log(obj.age) // 2obj.age = 4console.log(obj.age) // 5 静态方法和私有方法属性​ 有静态方法，没有私有属性和私有方法，但可以通过其他方式实现，比如symbol。 静态方法​ 有关键字static的方法不能被实例继承，而是通过类直接调用，这种方法就叫”静态方法“。(静态方法可以和非静态方法重名；如果静态方法中有this关键字，那么这个this代表的是类，而非类的实例) 私有属性​ 类本身的属性，而不是通过constructor挂载实例this上的属性，比如Super.props = 1. 目前有了提案： 可以直接加关键字static定义静态属性 实例属性可以不用必须写在constructor中了。 新增属性new.target​ 新增属性new.target，用在构造函数中，用来判断实例对象是否通过new关键字来创建的，还有一种方法判断就是this instanceof Person 对比es5很多特性都和es5是一致的，但有些特性就不同： 1. 类的内部所有定义的方法都是不可枚举的。 2. 默认就是严格模式。在类或者模块内部，默认就是严格模式。 3. 必须使用new进行调用，否则会报错。 4. 没有变量提升。 原型相关API hasOwnProperty用来判断对象是否自身拥有某属性。 getPrototypeOf方法可以用来判断类的继承关系；.proto属性的替代方法，获取对象的原型。 Object.keys是遍历不到prototype的，它只遍历可枚举的自身属性。 Object.getOwnPropertyNames返回对象所有可枚举不可枚举的属性和方法。 继承es5和es6es5原型链只有一条，即prototype； es6原型链有两条，一条是类本身实现属性继承(这样就子类就可以继承父类的静态方法)，相当于是es5中的call/apply，另一条才是prototype。 内部对象没有静态引用。 ​ 子类的this需要通过父类的constructor完成塑造，得到与父类同样的实例属性和方法，然后在对其进行加工，否则子类是得不到this对象的。 getPrototypeOf()​ 判断继承关系 super​ 既可以当函数使用也可以当对象使用。 super()调用父类构造函数；super.method()调用父类方法 作为函数代表的是父类的构造函数，内部this指向的是子类。只能用在子类的构造函数中。 super() = A.prototype.constructor.call(this) 作为对象，在普通方法中指向的是父类的原型对象（不能访问父类的，this指向子类实例），在静态方法中指向的是父类（this指向子类）。 使用地方可以用在class中和对象属性为method()中。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://zhanghy7.github.io/categories/javaScript/"},{"name":"es6","slug":"javaScript/es6","permalink":"http://zhanghy7.github.io/categories/javaScript/es6/"}],"tags":[]},{"title":"搭建个人博客(hexo)","slug":"搭建个人博客-hexo","date":"2018-11-29T06:32:28.000Z","updated":"2018-11-29T08:11:27.072Z","comments":true,"path":"2018/11/29/搭建个人博客-hexo/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/搭建个人博客-hexo/","excerpt":"","text":"使用hexo+git page搭建自己的博客新建项目前提是自己需要新建自己的git page，在下边的第三步进行关联。 npm install -g hexo-cli hexo init myBlog 进入项目找到_config.yml文件，修改配置： 安装git部署插件：npm install hexo-deployer-git –save 启动本地项目：hexo server 自选主题 主题在线查看传送门 选好主题后进入myBlog下载主题。例如:git clone https://github.com/levblanc/hexo-theme-aero-dual.git themes/aero-dual 重启本地服务查看主题：hexo server个性化修改主题一般来说我们都要修改主题，让它变成我们自己的内容： 修改主题中的_config.yml文件后（注意这里一定得是这个主题里的配置文件，在themes），就可以生成自己的主页了。 配置文件长这样：试用了一个主题长这个样子： 其中遇到的坑点： 配置文件中的主题图片在哪里？ 写作并发布写作这块使用hexo-admin进行博客管理，具体使用方式如下： 进入项目myBlog安装hexo-admin包： npm i hexo-admin --save 启动项目，并进入localhost:4000/admin，就可以看到博客管理界面。 在posts下就可以新增页面进行文件编辑了 （page和posts布局有什么区别还有待研究） 原理分析从编辑md到转为html，再到部署（包括部署地址）","categories":[],"tags":[]},{"title":"webStorm主题设置","slug":"webStorm主题设置","date":"2018-11-29T03:27:00.000Z","updated":"2018-11-29T03:34:59.413Z","comments":true,"path":"2018/11/29/webStorm主题设置/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/webStorm主题设置/","excerpt":"","text":"webStorm主题设置 一、下载主题 两个地址： webStormThemes color Themes 二、导入主题 File-&gt;Import Setting 选择自己下载的主题（jar包）后导入即可","categories":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/tags/tools/"}]}]}