{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"zhanghy7","url":"http://zhanghy7.github.io"},"pages":[],"posts":[{"title":"mysql常用命令","slug":"mysql常用命令","date":"2018-12-10T10:20:35.000Z","updated":"2018-12-10T10:41:42.040Z","comments":true,"path":"2018/12/10/mysql常用命令/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mysql常用命令/","excerpt":"","text":"mysql常用命令因为我用的是mac，可能某些命令会跟windows上不一样。 启动、重启和关闭前提是通过命令行启动服务的才能通过命令行关闭和重启。 启动：/usr/local/mysql/support-files/mysql.server start```12重启：```sudo /usr/local/mysql/support-files/mysql.server restart 关闭：/usr/local/mysql/support-files/mysql.server stop```1234## 登录、退出本地登录： ```mysql -u root -p (以用户名root身份使用密码登录) 远程登录：mysql -h123.123.123.123 -u root -p 退出：exit","categories":[],"tags":[]},{"title":"mac命令行配置文件","slug":"mac命令行配置文件","date":"2018-12-10T10:03:37.000Z","updated":"2018-12-10T10:04:08.571Z","comments":true,"path":"2018/12/10/mac命令行配置文件/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/mac命令行配置文件/","excerpt":"","text":"~/.bash_profile","categories":[],"tags":[]},{"title":"api接口管理系统之rap2","slug":"api接口管理系统之rap2","date":"2018-12-10T09:00:24.000Z","updated":"2018-12-10T09:00:56.113Z","comments":true,"path":"2018/12/10/api接口管理系统之rap2/","link":"","permalink":"http://zhanghy7.github.io/2018/12/10/api接口管理系统之rap2/","excerpt":"","text":"简书","categories":[],"tags":[]},{"title":"http之传输本质和content-type","slug":"Untitled","date":"2018-12-07T08:29:24.000Z","updated":"2018-12-11T13:49:57.814Z","comments":true,"path":"2018/12/07/Untitled/","link":"","permalink":"http://zhanghy7.github.io/2018/12/07/Untitled/","excerpt":"","text":"http之前后端数据传递数据到底是以什么形式在网络中进行传输的？ 大家都知道，前后端通过数据请求和响应进行交互，进而完成整个网站功能。在这个过程中数据的传输就变得异常重要了，由此引发的困惑我许久的问题：“这个数据是以什么形式传递的呢？” 网上的解释是网络数据是以 http协议(超文本协议) 进行传输的，那么这个数据在传递过程中是以文本形式传输的吗？答案是非也，所有网络数据都是以二进制流进行传输的，至于我们捕获到的文本形式的的请求其实是二进制数据流经过编辑器等处理过的文本信息。 注意点：http的超级文本其实就是二进制在http协议中的存在形式 常见的请求方式HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中post请求通常用于文件的上传、表单的提交等向服务器端发送数据。 四种post请求的content-typeapplication/x-www-form-urlencoded这种方式是最常见的请求头，像ajax、以及浏览器原生的form表单提交默认请求头都是采用这种方式。 表现形式：一组属性名和属性值以=相连，不同属性之间以&amp;符号相连，和浏览器中的url组成方式一样。 图示： multipart/form-data这种方式通常用于文件、图片等的上传。 表现形式：由三部分组成：boundary+content+content-type(这个不一定都有，只有在上传文件的时候会有)。其中boundary是用于识别不同数据的分隔符，content-type是上传文件的文件类型。 图示： application/json这种方式现在普遍应用于非文件类型的数据提交。采用json格式传输数据是一种非常好的方式，这种方式不仅传输的数据量少，而且可以嵌套多层传递复杂的数据。 text/xml还有一种text/xml的古老的方式，谁有兴趣谁去研究一下吧zzz 参考文献 https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data post提交的四种方式 http的网络传输方式 fetch设置请求头","categories":[],"tags":[]},{"title":"非暴力沟通读书笔记一","slug":"非暴力沟通读书笔记一","date":"2018-12-06T13:06:00.000Z","updated":"2018-12-07T07:31:22.124Z","comments":true,"path":"2018/12/06/非暴力沟通读书笔记一/","link":"","permalink":"http://zhanghy7.github.io/2018/12/06/非暴力沟通读书笔记一/","excerpt":"","text":"非暴力沟通读书笔记一四要素非暴力沟通的要素：观察、感受、需要、要求。 我们在沟通过程中按照这四个方式把自己的想法完整的表达出来，这样的表达方式既能把自己的思想表达出来又能让对方明白你的需求，避免因为某一环节的缺失造成双方的沟通障碍，进而引发矛盾。 精彩故事片段 一位母亲对青春期的儿子说：“弗利克斯，看到咖啡桌角下你的两双脏袜子，我很不高兴，我更需要的是干净的环境，请你把它们放到洗衣机里去洗掉”。","categories":[],"tags":[]},{"title":"细说margin负值","slug":"细说margin负值","date":"2018-12-02T15:04:00.000Z","updated":"2018-12-06T07:03:59.621Z","comments":true,"path":"2018/12/02/细说margin负值/","link":"","permalink":"http://zhanghy7.github.io/2018/12/02/细说margin负值/","excerpt":"","text":"marginmargin作为css中最常用的属性之一，但是在使用过程中我发现对于margin的正值用的很顺畅，但是设置负值就会出现各种各样奇奇怪怪的现象，所以整理一份笔记帮助自己理解margin这个属性。 正值正值没什么好说的，哪个方向设多少就在哪个方向增加多少外边距。 负值这里主要整理一下负值的知识点。 基础知识margin的设置会影响元素的表现形式，那么我们首先要知道决定元素表现形式的三要素，这会对之后的知识点的理解有重大帮助： margin设置的方向 元素是否浮动 元素的定位方式具体表现形式元素无浮动无定位 敌不动我动：margin-top和margin-left为负，元素向该方向移动。 我不动敌动：margin-right和margin-bottom为负，该元素不动，该方向的相邻元素会移动相应的距离覆盖到该元素。 这种情况下如果元素没有设置宽度，那么设置了margin-left和margin-right之后元素的宽度会增加，和padding一个效果。未设置宽度、margin的图示：未设置宽度、设置margin的图示： 元素无浮动，定位为relative表现形式和无定位无浮动一致。 元素无浮动，定位为absolute margin-top和margin-left和无浮动无定位一样。 margin-right和margin-bottom无效果，因为脱离了文档流。 元素设置了浮动（float元素是包裹在他们的block元素中浮动的，不会超出父级block元素） 浮动方向和margin方向一致时，元素向相应的方向移动相应的距离。 浮动元素和margin方向不一致，元素本身不动，相邻元素向该元素移动相应的距离。 参考文章： 负margin用法权威指南","categories":[{"name":"css基础","slug":"css基础","permalink":"http://zhanghy7.github.io/categories/css基础/"}],"tags":[]},{"title":"专业英文单词学习","slug":"专业英文单词学习","date":"2018-11-30T06:01:00.000Z","updated":"2018-12-07T08:13:53.336Z","comments":true,"path":"2018/11/30/专业英文单词学习/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/专业英文单词学习/","excerpt":"","text":"英文单词 并行： parallel 阻塞： stalled 二进制：binary 堆：heap 队列：queue 栈：stack 进程：process 线程：thread 问题：issue 仪表盘：dashboard 用于文件内的字符串的查找：grep 形实转换程序：thunk 构成、组成：compose 回来的、回家的：redux 重构：refactor 章：chapter 账号：account 订阅：subscription 发布：publish 教程：tutorial 博客：blog 社区；团体：community 直到；就…而言：as far as 传说；冒险故事：saga 就…而言：in term of 语法：syntax 请求响应：request/response 任务：task 伪造：forgery CSRF(cross-site request forgery)：跨站点请求伪造 猜测：guess 移动：shift 作用域：scope 兼容：compatible 驾驶；解决： navigate 记录： record 持久化： persistant 数据结构：structure 观察者：observer 检查：inspect 冒泡: propagation bubble 修饰者: decorator 中间的；媒介: medium 局部的，偏爱的: partial 阶乘的: factorial 允许跨域: access-control-allow-origin 取： fetch 独一无二的: unique 概念: concept 预先装置的: preset 结合: combine （为小说等）写(续篇)： sequelize 权利：authority 检测到的: detected 小数的:decimal 被动的，消极的：passive 官方的：official 结合：integrate 标记：tick 部分：segment 别名：alias 平原；朴素的：plain","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://zhanghy7.github.io/tags/English/"}]},{"title":"软件架构模式","slug":"软件架构模式","date":"2018-11-30T06:00:00.000Z","updated":"2018-11-30T06:04:37.523Z","comments":true,"path":"2018/11/30/软件架构模式/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/软件架构模式/","excerpt":"","text":"软件架构模式MVC 特点：单向通信 MVVM 特点： view层和model层不再通信 view和viewModel层双向绑定，同时改变，无需专门触发 在前端来说各部分代表的是什么？Model数据（自定义的数据、服务器返回的数据） Viewhtml和css，用户能看到的东西 ViewModel连接view和Model的桥梁，数据视图双向绑定。","categories":[{"name":"宏观架构","slug":"宏观架构","permalink":"http://zhanghy7.github.io/categories/宏观架构/"}],"tags":[]},{"title":"vue使用笔记","slug":"vue使用笔记","date":"2018-11-30T05:59:00.000Z","updated":"2018-11-30T06:05:05.868Z","comments":true,"path":"2018/11/30/vue使用笔记/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/vue使用笔记/","excerpt":"","text":"vue使用计算属性和监听计算属性(computed)缓存特性和使用场景​ 依赖的数据变化时候此字段的数据跟着变化，所以这里就存在缓存的情况，如果依赖的数据没有变化，这时候这个数据本身也不变。 可以加setterclass和style属性​ vue为这两属性做了增强，本来v-bind绑定的只能是字符串，这里支持对象和数组。 class​ 可以与普通的class共存，可以同时写(自己之前的写法都是一次只用一个，以为不能混用。。。) ​ 对象可以写在属性里，也可以写在data中、computed中。 ​ 数组形式的话直接写字段名，最终渲染出来是字段对应的值。 ###style ​ 支持驼峰命名和短横线命名。 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt; 1234data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; ​ 当使用:style的时候，vue会自动添加浏览器需要的前缀。 ​ 可以给一个css属性绑定多个值，放在一个数组中，这样就只会渲染浏览器支持的最后一个值。 vue.filter过滤器，用于处理一些转义等字段。 使用全局123Vue.filter(&apos;test&apos;,function(value)&#123;return value + &apos;test&apos;&#125;);&#123;&#123;msg | test&#125;&#125;&lt;input v-model=&quot;msg | test&quot;/&gt; 局部在组件内部添加filter属性 class对象写法数组写法访问数据及方法只有写在template里边默认是在当前组件内取值，不用加this 子组件中的data不跟随props变化而变化data中的值只会在组件第一次初始化数据时候执行一次，并不会跟随props的变化而变化。 想要响应式变化就需要用到computed和watch。 事件监听使用（模板非字符串模板）不同于组件和props，事件名不会被用作一个js变量名或属性名，所以没有理由使用camelCase或pascalCase命名。事件监听器在DOM模板中都会转为小写的，因为html不区分大小写。推荐使用kebab-case命名方式。 props中有对象子组件可以直接修改对象内的值装修助手量房端详情页采用这种方式进行修改 vue生命周期执行过程12每种生命周期由父组件向子组件执行，接着在执行下一个生命周期，比如会先执行所有的created函数之后再执行mounted函数。但是如果哪个组件的生成需要依赖异步请求的数据，这个规则不适用。一般来说它会在其他父组件加载完成之后按照生命周期顺序执行自己的生命周期 注意事项生命周期函数不支持async因为整个 diff 和 render 的算法都是基于组件生命周期同步执行的前提下的。而且任意一个组件的生命周期可能异步推迟最后的渲染完成是绝对不应该出现的设计。github问题地址 css作用域问题​ vue-cli命令提供了两种内置的解决css样式覆盖问题的方案，scoped和css modules。 scoped使用​ 简单易用，在style标签内写上scoped属性即可。 原理​ 为class名称后边添加data-xxxx这样一串字符串用来确保css样式的唯一。 缺点1. 若父组件和子组件有同名class，那么父组件设置的样式还会作用于子组件。 2. 对v-html中的元素设置的样式是不生效的。 css modules​ 需要使用vue-cli3生成项目脚手架才能直接用，否则需要自己配置webpack。 配置webpack很简单，就是在css-loader后边加个?modules打开css modules。 loader: &#39;css-loader?modules&#39;, 使用​ style标签中添加module属性，但是在class中需要通过$style.xxx来设置样式 &lt;div :class=&quot;$style.test&quot;&gt;&lt;/div&gt; 原理​ 将每个css名称编译成为唯一的字符串 缺点​ 使用复杂，所有样式都要通过$style操作 优点 名称唯一 可以显示的使用$style去操作css，甚至是在钩子函数中进行操作。 ​","categories":[{"name":"vue","slug":"vue","permalink":"http://zhanghy7.github.io/categories/vue/"}],"tags":[]},{"title":"hybrid","slug":"hybrid","date":"2018-11-30T05:58:00.000Z","updated":"2018-11-30T06:05:48.176Z","comments":true,"path":"2018/11/30/hybrid/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/hybrid/","excerpt":"","text":"hybrid特征 可用的系统、网络资源和web app有本质的区别。 支持更新的浏览器特性。 可实现离线应用。利用h5的缓存机制和native自身的文件写入。 需要兼容多版本多机型的设备。 可以调用native的原生功能。","categories":[{"name":"hybrid","slug":"hybrid","permalink":"http://zhanghy7.github.io/categories/hybrid/"}],"tags":[]},{"title":"es6-class","slug":"es6-class","date":"2018-11-30T05:57:00.000Z","updated":"2018-11-30T06:06:25.250Z","comments":true,"path":"2018/11/30/es6-class/","link":"","permalink":"http://zhanghy7.github.io/2018/11/30/es6-class/","excerpt":"","text":"es6class​ js提供的一个语法糖，用来更清晰的定义类，有constructor属性，constructor里边定义类的属性，constructor默认返回实例对象（即this），但也可以返回其他对象。 ​ 它的方法都挂在prototype上。 示例代码如下： Point &#123;1234567891011121314151617181920 constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; set、get关键字在class内部可以使用set和get关键字，对某个属性设置存值函数和取值函数,示例代码： Super&#123;123456789101112131415constructor(name,age) &#123; this.name = name this.test = age&#125;set age(value) &#123; this.test = value +1&#125;get age() &#123; return this.test &#125;&#125;var obj = new Super(&apos;aaa&apos;,2)console.log(obj.age) // 2obj.age = 4console.log(obj.age) // 5 静态方法和私有方法属性​ 有静态方法，没有私有属性和私有方法，但可以通过其他方式实现，比如symbol。 静态方法​ 有关键字static的方法不能被实例继承，而是通过类直接调用，这种方法就叫”静态方法“。(静态方法可以和非静态方法重名；如果静态方法中有this关键字，那么这个this代表的是类，而非类的实例) 私有属性​ 类本身的属性，而不是通过constructor挂载实例this上的属性，比如Super.props = 1. 目前有了提案： 可以直接加关键字static定义静态属性 实例属性可以不用必须写在constructor中了。 新增属性new.target​ 新增属性new.target，用在构造函数中，用来判断实例对象是否通过new关键字来创建的，还有一种方法判断就是this instanceof Person 对比es5很多特性都和es5是一致的，但有些特性就不同： 1. 类的内部所有定义的方法都是不可枚举的。 2. 默认就是严格模式。在类或者模块内部，默认就是严格模式。 3. 必须使用new进行调用，否则会报错。 4. 没有变量提升。 原型相关API hasOwnProperty用来判断对象是否自身拥有某属性。 getPrototypeOf方法可以用来判断类的继承关系；.proto属性的替代方法，获取对象的原型。 Object.keys是遍历不到prototype的，它只遍历可枚举的自身属性。 Object.getOwnPropertyNames返回对象所有可枚举不可枚举的属性和方法。 继承es5和es6es5原型链只有一条，即prototype； es6原型链有两条，一条是类本身实现属性继承(这样就子类就可以继承父类的静态方法)，相当于是es5中的call/apply，另一条才是prototype。 内部对象没有静态引用。 ​ 子类的this需要通过父类的constructor完成塑造，得到与父类同样的实例属性和方法，然后在对其进行加工，否则子类是得不到this对象的。 getPrototypeOf()​ 判断继承关系 super​ 既可以当函数使用也可以当对象使用。 super()调用父类构造函数；super.method()调用父类方法 作为函数代表的是父类的构造函数，内部this指向的是子类。只能用在子类的构造函数中。 super() = A.prototype.constructor.call(this) 作为对象，在普通方法中指向的是父类的原型对象（不能访问父类的，this指向子类实例），在静态方法中指向的是父类（this指向子类）。 使用地方可以用在class中和对象属性为method()中。","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://zhanghy7.github.io/categories/javaScript/"},{"name":"es6","slug":"javaScript/es6","permalink":"http://zhanghy7.github.io/categories/javaScript/es6/"}],"tags":[]},{"title":"搭建个人博客(hexo)","slug":"搭建个人博客-hexo","date":"2018-11-29T06:32:28.000Z","updated":"2018-11-29T08:11:27.072Z","comments":true,"path":"2018/11/29/搭建个人博客-hexo/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/搭建个人博客-hexo/","excerpt":"","text":"使用hexo+git page搭建自己的博客新建项目前提是自己需要新建自己的git page，在下边的第三步进行关联。 npm install -g hexo-cli hexo init myBlog 进入项目找到_config.yml文件，修改配置： 安装git部署插件：npm install hexo-deployer-git –save 启动本地项目：hexo server 自选主题 主题在线查看传送门 选好主题后进入myBlog下载主题。例如:git clone https://github.com/levblanc/hexo-theme-aero-dual.git themes/aero-dual 重启本地服务查看主题：hexo server个性化修改主题一般来说我们都要修改主题，让它变成我们自己的内容： 修改主题中的_config.yml文件后（注意这里一定得是这个主题里的配置文件，在themes），就可以生成自己的主页了。 配置文件长这样：试用了一个主题长这个样子： 其中遇到的坑点： 配置文件中的主题图片在哪里？ 写作并发布写作这块使用hexo-admin进行博客管理，具体使用方式如下： 进入项目myBlog安装hexo-admin包： npm i hexo-admin --save 启动项目，并进入localhost:4000/admin，就可以看到博客管理界面。 在posts下就可以新增页面进行文件编辑了 （page和posts布局有什么区别还有待研究） 原理分析从编辑md到转为html，再到部署（包括部署地址）","categories":[],"tags":[]},{"title":"webStorm主题设置","slug":"webStorm主题设置","date":"2018-11-29T03:27:00.000Z","updated":"2018-11-29T03:34:59.413Z","comments":true,"path":"2018/11/29/webStorm主题设置/","link":"","permalink":"http://zhanghy7.github.io/2018/11/29/webStorm主题设置/","excerpt":"","text":"webStorm主题设置 一、下载主题 两个地址： webStormThemes color Themes 二、导入主题 File-&gt;Import Setting 选择自己下载的主题（jar包）后导入即可","categories":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://zhanghy7.github.io/tags/tools/"}]}]}